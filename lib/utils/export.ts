// Progress entry interface for export functionality
interface ProgressEntry {
  id: string;
  date: Date;
  metric: string;
  value: any;
  notes?: string;
}

/**
 * Convert array of objects to CSV
 */
export function convertToCSV(data: any[], headers?: string[]): string {
  if (data.length === 0) return '';

  // Get headers from first object if not provided
  const csvHeaders = headers || Object.keys(data[0]);

  // Create CSV header row
  const headerRow = csvHeaders.join(',');

  // Create data rows
  const dataRows = data.map((item) => {
    return csvHeaders
      .map((header) => {
        const value = item[header];

        // Handle different data types
        if (value === null || value === undefined) {
          return '';
        }

        // Escape quotes and wrap in quotes if contains comma or quote
        const stringValue = String(value);
        if (stringValue.includes(',') || stringValue.includes('"') || stringValue.includes('\n')) {
          return `"${stringValue.replace(/"/g, '""')}"`;
        }

        return stringValue;
      })
      .join(',');
  });

  return [headerRow, ...dataRows].join('\n');
}

/**
 * Export progress data to CSV
 */
export function exportProgressToCSV(progressData: ProgressEntry[]): string {
  const formattedData = progressData.map((entry) => ({
    Date: new Date(entry.date).toLocaleDateString(),
    Metric: entry.metric,
    Value: typeof entry.value === 'object' ? JSON.stringify(entry.value) : entry.value,
    Notes: (entry as any).notes || '',
  }));

  return convertToCSV(formattedData);
}

/**
 * Generate simple PDF report (HTML-based)
 * In production, use a library like pdfkit or puppeteer
 */
export function generatePDFReport(data: {
  title: string;
  clientName: string;
  dateRange: { start: string; end: string };
  progressData: ProgressEntry[];
  summary: Record<string, any>;
}): string {
  const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>${data.title}</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 40px;
      color: #333;
    }
    h1 {
      color: #2563eb;
      border-bottom: 3px solid #2563eb;
      padding-bottom: 10px;
    }
    .header-info {
      margin: 20px 0;
      padding: 15px;
      background: #f3f4f6;
      border-radius: 8px;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 20px 0;
    }
    th, td {
      padding: 12px;
      text-align: left;
      border-bottom: 1px solid #e5e7eb;
    }
    th {
      background: #f9fafb;
      font-weight: 600;
      color: #1f2937;
    }
    tr:hover {
      background: #f9fafb;
    }
    .summary-box {
      background: #eff6ff;
      padding: 20px;
      border-radius: 8px;
      margin: 20px 0;
    }
    .summary-box h2 {
      margin-top: 0;
      color: #1e40af;
    }
    .metric-row {
      display: flex;
      justify-content: space-between;
      padding: 8px 0;
      border-bottom: 1px solid #dbeafe;
    }
    .footer {
      margin-top: 40px;
      padding-top: 20px;
      border-top: 2px solid #e5e7eb;
      text-align: center;
      color: #6b7280;
      font-size: 14px;
    }
    @media print {
      body { margin: 20px; }
      .no-print { display: none; }
    }
  </style>
</head>
<body>
  <h1>${data.title}</h1>
  
  <div class="header-info">
    <p><strong>Client:</strong> ${data.clientName}</p>
    <p><strong>Report Period:</strong> ${data.dateRange.start} to ${data.dateRange.end}</p>
    <p><strong>Generated:</strong> ${new Date().toLocaleString()}</p>
  </div>

  <div class="summary-box">
    <h2>Summary</h2>
    ${Object.entries(data.summary)
      .map(
        ([key, value]) => `
      <div class="metric-row">
        <span><strong>${formatKey(key)}:</strong></span>
        <span>${formatValue(value)}</span>
      </div>
    `
      )
      .join('')}
  </div>

  <h2>Progress Details</h2>
  <table>
    <thead>
      <tr>
        <th>Date</th>
        <th>Metric</th>
        <th>Value</th>
        <th>Notes</th>
      </tr>
    </thead>
    <tbody>
      ${data.progressData
        .map(
          (entry) => `
        <tr>
          <td>${new Date(entry.date).toLocaleDateString()}</td>
          <td>${entry.metric}</td>
          <td>${formatValue(entry.value)}</td>
          <td>${(entry as any).notes || '-'}</td>
        </tr>
      `
        )
        .join('')}
    </tbody>
  </table>

  <div class="footer">
    <p>This report was automatically generated by FitCoach Pro</p>
    <p>For questions or concerns, please contact your trainer</p>
  </div>

  <script class="no-print">
    // Auto-print when loaded
    window.onload = function() {
      if (window.location.search.includes('print=true')) {
        window.print();
      }
    };
  </script>
</body>
</html>
  `;

  return html;
}

// Helper functions
function formatKey(key: string): string {
  return key
    .replace(/([A-Z])/g, ' $1')
    .replace(/^./, (str) => str.toUpperCase())
    .trim();
}

function formatValue(value: any): string {
  if (typeof value === 'object' && value !== null) {
    return JSON.stringify(value);
  }
  if (typeof value === 'number') {
    return value.toFixed(2);
  }
  return String(value);
}

/**
 * Download trigger (client-side helper)
 */
export function triggerDownload(content: string, filename: string, mimeType: string): void {
  const blob = new Blob([content], { type: mimeType });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}